<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/lib/db.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/lib/db.ts" />
              <option name="originalContent" value="/**&#10; * Database Service - PostgreSQL Edition&#10; * Comprehensive database operations for Project ME with multi-user support&#10; */&#10;&#10;import prisma from './prisma'&#10;&#10;// ==================== TYPES ====================&#10;&#10;export interface User {&#10;  id: string&#10;  email?: string | null&#10;  name?: string | null&#10;  username?: string | null&#10;  createdAt: Date&#10;  updatedAt: Date&#10;  lastLoginAt?: Date | null&#10;}&#10;&#10;export interface Task {&#10;  id: string&#10;  userId?: string | null&#10;  title: string&#10;  description?: string | null&#10;  status: string&#10;  type: string&#10;  payload?: any&#10;  tags?: string[]&#10;  createdAt: Date&#10;  updatedAt: Date&#10;  lastRunAt?: Date | null&#10;  runnerStatus?: string | null&#10;  outputText?: string | null&#10;  outputRaw?: any&#10;  errorMessage?: string | null&#10;  priority?: number&#10;  isPublic?: boolean&#10;  executionTime?: number | null&#10;}&#10;&#10;export interface Event {&#10;  id: string&#10;  userId?: string | null&#10;  taskId?: string | null&#10;  eventType: string&#10;  timestamp: Date&#10;  data?: any&#10;  level?: string&#10;}&#10;&#10;export interface Settings {&#10;  id: string&#10;  userId?: string | null&#10;  runnerUrl?: string | null&#10;  runnerToken?: string | null&#10;  preferences?: any&#10;  updatedAt: Date&#10;  createdAt: Date&#10;}&#10;&#10;// ==================== USER OPERATIONS ====================&#10;&#10;export async function createUser(data: {&#10;  email?: string&#10;  name?: string&#10;  username?: string&#10;  passwordHash?: string&#10;}) {&#10;  console.log('[DB] Creating user:', data.email || data.username)&#10;&#10;  const user = await prisma.user.create({&#10;    data: {&#10;      email: data.email,&#10;      name: data.name,&#10;      username: data.username,&#10;      passwordHash: data.passwordHash,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] User created:', user.id)&#10;  return user&#10;}&#10;&#10;export async function getUserById(id: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { id },&#10;    include: {&#10;      settings: true,&#10;    },&#10;  })&#10;}&#10;&#10;export async function getUserByEmail(email: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { email },&#10;  })&#10;}&#10;&#10;export async function getUserByUsername(username: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { username },&#10;  })&#10;}&#10;&#10;// ==================== TASK OPERATIONS ====================&#10;&#10;export async function getTasks(filters?: {&#10;  userId?: string&#10;  status?: string&#10;  type?: string&#10;  isPublic?: boolean&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  console.log('[DB] Getting tasks with filters:', filters)&#10;&#10;  const where: any = {}&#10;&#10;  if (filters?.userId !== undefined) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.status) {&#10;    where.status = filters.status&#10;  }&#10;&#10;  if (filters?.type) {&#10;    where.type = filters.type&#10;  }&#10;&#10;  if (filters?.isPublic !== undefined) {&#10;    where.isPublic = filters.isPublic&#10;  }&#10;&#10;  const tasks = await prisma.task.findMany({&#10;    where,&#10;    orderBy: [&#10;      { priority: 'desc' },&#10;      { createdAt: 'desc' },&#10;    ],&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;    },&#10;  })&#10;&#10;  console.log(`[DB] Found ${tasks.length} tasks`)&#10;  return tasks&#10;}&#10;&#10;export async function getTaskById(id: string) {&#10;  console.log('[DB] Getting task by ID:', id)&#10;&#10;  const task = await prisma.task.findUnique({&#10;    where: { id },&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;      events: {&#10;        orderBy: { timestamp: 'desc' },&#10;        take: 50,&#10;      },&#10;    },&#10;  })&#10;&#10;  if (!task) {&#10;    console.log('[DB] Task not found:', id)&#10;    return null&#10;  }&#10;&#10;  console.log('[DB] Task found:', task.id)&#10;  return task&#10;}&#10;&#10;export async function createTask(data: {&#10;  userId?: string&#10;  title: string&#10;  description?: string&#10;  type?: string&#10;  payload?: any&#10;  tags?: string[]&#10;  priority?: number&#10;  isPublic?: boolean&#10;}) {&#10;  console.log('[DB] Creating task:', data.title)&#10;&#10;  const task = await prisma.task.create({&#10;    data: {&#10;      userId: data.userId,&#10;      title: data.title,&#10;      description: data.description,&#10;      type: data.type || 'general',&#10;      payload: data.payload,&#10;      tags: data.tags || [],&#10;      priority: data.priority || 0,&#10;      isPublic: data.isPublic || false,&#10;      status: 'pending',&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Task created:', task.id)&#10;  return task&#10;}&#10;&#10;export async function updateTask(id: string, data: Partial&lt;Task&gt;) {&#10;  console.log('[DB] Updating task:', id)&#10;&#10;  const task = await prisma.task.update({&#10;    where: { id },&#10;    data: {&#10;      title: data.title,&#10;      description: data.description,&#10;      status: data.status,&#10;      type: data.type,&#10;      payload: data.payload,&#10;      tags: data.tags,&#10;      lastRunAt: data.lastRunAt,&#10;      runnerStatus: data.runnerStatus,&#10;      outputText: data.outputText,&#10;      outputRaw: data.outputRaw,&#10;      errorMessage: data.errorMessage,&#10;      priority: data.priority,&#10;      isPublic: data.isPublic,&#10;      executionTime: data.executionTime,&#10;      updatedAt: new Date(),&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Task updated:', task.id)&#10;  return task&#10;}&#10;&#10;export async function deleteTask(id: string) {&#10;  console.log('[DB] Deleting task:', id)&#10;&#10;  await prisma.task.delete({&#10;    where: { id },&#10;  })&#10;&#10;  console.log('[DB] Task deleted:', id)&#10;}&#10;&#10;// ==================== EVENT OPERATIONS ====================&#10;&#10;export async function getEvents(filters?: {&#10;  userId?: string&#10;  taskId?: string&#10;  eventType?: string&#10;  level?: string&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  console.log('[DB] Getting events with filters:', filters)&#10;&#10;  const where: any = {}&#10;&#10;  if (filters?.userId) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.taskId) {&#10;    where.taskId = filters.taskId&#10;  }&#10;&#10;  if (filters?.eventType) {&#10;    where.eventType = filters.eventType&#10;  }&#10;&#10;  if (filters?.level) {&#10;    where.level = filters.level&#10;  }&#10;&#10;  const events = await prisma.event.findMany({&#10;    where,&#10;    orderBy: { timestamp: 'desc' },&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;      task: {&#10;        select: {&#10;          id: true,&#10;          title: true,&#10;        },&#10;      },&#10;    },&#10;  })&#10;&#10;  console.log(`[DB] Found ${events.length} events`)&#10;  return events&#10;}&#10;&#10;export async function createEvent(data: {&#10;  userId?: string&#10;  taskId?: string&#10;  eventType: string&#10;  data?: any&#10;  level?: string&#10;}) {&#10;  console.log('[DB] Creating event:', data.eventType)&#10;&#10;  const event = await prisma.event.create({&#10;    data: {&#10;      userId: data.userId,&#10;      taskId: data.taskId,&#10;      eventType: data.eventType,&#10;      data: data.data,&#10;      level: data.level || 'info',&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Event created:', event.id)&#10;  return event&#10;}&#10;&#10;// ==================== SETTINGS OPERATIONS ====================&#10;&#10;export async function getSettings(userId?: string) {&#10;  console.log('[DB] Getting settings for user:', userId || 'global')&#10;&#10;  let settings = await prisma.settings.findFirst({&#10;    where: { userId: userId ?? null },&#10;  })&#10;&#10;  // Create default settings if not exists&#10;  if (!settings) {&#10;    console.log('[DB] Settings not found, creating defaults')&#10;    settings = await prisma.settings.create({&#10;      data: {&#10;        userId: userId,&#10;        preferences: {},&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Settings loaded:', settings.id)&#10;  return settings&#10;}&#10;&#10;export async function updateSettings(&#10;  userId: string | undefined,&#10;  data: {&#10;    runnerUrl?: string | null&#10;    runnerToken?: string | null&#10;    preferences?: any&#10;  }&#10;) {&#10;  console.log('[DB] Updating settings for user:', userId || 'global')&#10;&#10;  // Find existing settings&#10;  const existing = await prisma.settings.findFirst({&#10;    where: { userId: userId ?? null },&#10;  })&#10;&#10;  let settings&#10;  if (existing) {&#10;    // Update existing&#10;    settings = await prisma.settings.update({&#10;      where: { id: existing.id },&#10;      data: {&#10;        runnerUrl: data.runnerUrl,&#10;        runnerToken: data.runnerToken,&#10;        preferences: data.preferences,&#10;        updatedAt: new Date(),&#10;      },&#10;    })&#10;  } else {&#10;    // Create new&#10;    settings = await prisma.settings.create({&#10;      data: {&#10;        userId: userId,&#10;        runnerUrl: data.runnerUrl,&#10;        runnerToken: data.runnerToken,&#10;        preferences: data.preferences || {},&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Settings updated:', settings.id)&#10;  return settings&#10;}&#10;&#10;// ==================== AUDIT LOG OPERATIONS ====================&#10;&#10;export async function createAuditLog(data: {&#10;  userId?: string&#10;  action: string&#10;  resource?: string&#10;  metadata?: any&#10;  ipAddress?: string&#10;  userAgent?: string&#10;}) {&#10;  console.log('[DB] Creating audit log:', data.action)&#10;&#10;  const log = await prisma.auditLog.create({&#10;    data: {&#10;      userId: data.userId,&#10;      action: data.action,&#10;      resource: data.resource,&#10;      metadata: data.metadata,&#10;      ipAddress: data.ipAddress,&#10;      userAgent: data.userAgent,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Audit log created:', log.id)&#10;  return log&#10;}&#10;&#10;export async function getAuditLogs(filters?: {&#10;  userId?: string&#10;  action?: string&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  const where: any = {}&#10;&#10;  if (filters?.userId) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.action) {&#10;    where.action = filters.action&#10;  }&#10;&#10;  return await prisma.auditLog.findMany({&#10;    where,&#10;    orderBy: { timestamp: 'desc' },&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;  })&#10;}&#10;&#10;// ==================== LLM SESSION OPERATIONS ====================&#10;&#10;export async function createLLMSession(data: {&#10;  userId?: string&#10;  sessionId: string&#10;  title?: string&#10;  systemPrompt?: string&#10;  metadata?: any&#10;}) {&#10;  console.log('[DB] Creating LLM session:', data.sessionId)&#10;&#10;  const session = await prisma.lLMSession.create({&#10;    data: {&#10;      userId: data.userId,&#10;      sessionId: data.sessionId,&#10;      title: data.title,&#10;      systemPrompt: data.systemPrompt,&#10;      metadata: data.metadata,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] LLM session created:', session.id)&#10;  return session&#10;}&#10;&#10;export async function getLLMSession(sessionId: string) {&#10;  return await prisma.lLMSession.findUnique({&#10;    where: { sessionId },&#10;    include: {&#10;      messages: {&#10;        orderBy: { timestamp: 'asc' },&#10;      },&#10;    },&#10;  })&#10;}&#10;&#10;export async function addLLMMessage(data: {&#10;  sessionId: string&#10;  role: string&#10;  content: string&#10;  metadata?: any&#10;}) {&#10;  console.log('[DB] Adding LLM message to session:', data.sessionId)&#10;&#10;  // Update session lastUsedAt&#10;  await prisma.lLMSession.update({&#10;    where: { sessionId: data.sessionId },&#10;    data: { lastUsedAt: new Date() },&#10;  })&#10;&#10;  const message = await prisma.lLMMessage.create({&#10;    data: {&#10;      session: {&#10;        connect: { sessionId: data.sessionId },&#10;      },&#10;      role: data.role,&#10;      content: data.content,&#10;      metadata: data.metadata,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] LLM message created:', message.id)&#10;  return message&#10;}&#10;&#10;// ==================== SANDBOX FILE OPERATIONS ====================&#10;&#10;export async function saveSandboxFile(data: {&#10;  userId?: string&#10;  path: string&#10;  content: string&#10;  mimeType?: string&#10;}) {&#10;  console.log('[DB] Saving sandbox file:', data.path)&#10;&#10;  // Check if file exists&#10;  const existing = await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: data.userId ?? null,&#10;      path: data.path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;&#10;  let file&#10;  if (existing) {&#10;    // Update existing file&#10;    file = await prisma.sandboxFile.update({&#10;      where: { id: existing.id },&#10;      data: {&#10;        content: data.content,&#10;        size: Buffer.byteLength(data.content, 'utf8'),&#10;        mimeType: data.mimeType,&#10;        updatedAt: new Date(),&#10;      },&#10;    })&#10;  } else {&#10;    // Create new file&#10;    file = await prisma.sandboxFile.create({&#10;      data: {&#10;        userId: data.userId,&#10;        path: data.path,&#10;        content: data.content,&#10;        size: Buffer.byteLength(data.content, 'utf8'),&#10;        mimeType: data.mimeType,&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Sandbox file saved:', file.id)&#10;  return file&#10;}&#10;&#10;export async function getSandboxFile(userId: string | undefined, path: string) {&#10;  return await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: userId ?? null,&#10;      path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;}&#10;&#10;export async function listSandboxFiles(userId?: string) {&#10;  return await prisma.sandboxFile.findMany({&#10;    where: {&#10;      userId: userId,&#10;      isDeleted: false,&#10;    },&#10;    orderBy: { updatedAt: 'desc' },&#10;  })&#10;}&#10;&#10;export async function deleteSandboxFile(userId: string | undefined, path: string) {&#10;  console.log('[DB] Deleting sandbox file:', path)&#10;&#10;  const file = await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: userId ?? null,&#10;      path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;&#10;  if (file) {&#10;    await prisma.sandboxFile.update({&#10;      where: { id: file.id },&#10;      data: {&#10;        isDeleted: true,&#10;      },&#10;    })&#10;    console.log('[DB] Sandbox file marked as deleted:', path)&#10;  } else {&#10;    console.log('[DB] Sandbox file not found:', path)&#10;  }&#10;}&#10;&#10;// ==================== UTILITY FUNCTIONS ====================&#10;&#10;export async function healthCheck() {&#10;  try {&#10;    await prisma.$queryRaw`SELECT 1`&#10;    return { ok: true, database: 'connected' }&#10;  } catch (error) {&#10;    console.error('[DB] Health check failed:', error)&#10;    return { ok: false, database: 'disconnected', error }&#10;  }&#10;}&#10;&#10;// Alias for API compatibility&#10;export const getDatabaseHealth = healthCheck&#10;&#10;export async function getDatabaseStats() {&#10;  const [&#10;    taskCount,&#10;    eventCount,&#10;    userCount,&#10;    sessionCount,&#10;  ] = await Promise.all([&#10;    prisma.task.count(),&#10;    prisma.event.count(),&#10;    prisma.user.count(),&#10;    prisma.lLMSession.count(),&#10;  ])&#10;&#10;  return {&#10;    tasks: taskCount,&#10;    events: eventCount,&#10;    users: userCount,&#10;    sessions: sessionCount,&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Database Service - PostgreSQL Edition&#10; * Comprehensive database operations for Project ME with multi-user support&#10; */&#10;&#10;import prisma from './prisma'&#10;&#10;// ==================== TYPES ====================&#10;&#10;export interface User {&#10;  id: string&#10;  email?: string | null&#10;  name?: string | null&#10;  username?: string | null&#10;  createdAt: Date&#10;  updatedAt: Date&#10;  lastLoginAt?: Date | null&#10;}&#10;&#10;export interface Task {&#10;  id: string&#10;  userId?: string | null&#10;  title: string&#10;  description?: string | null&#10;  status: string&#10;  type: string&#10;  payload?: any&#10;  tags?: string[]&#10;  createdAt: Date&#10;  updatedAt: Date&#10;  lastRunAt?: Date | null&#10;  runnerStatus?: string | null&#10;  outputText?: string | null&#10;  outputRaw?: any&#10;  errorMessage?: string | null&#10;  priority?: number&#10;  isPublic?: boolean&#10;  executionTime?: number | null&#10;}&#10;&#10;export interface Event {&#10;  id: string&#10;  userId?: string | null&#10;  taskId?: string | null&#10;  eventType: string&#10;  timestamp: Date&#10;  data?: any&#10;  level?: string&#10;}&#10;&#10;export interface Settings {&#10;  id: string&#10;  userId?: string | null&#10;  runnerUrl?: string | null&#10;  runnerToken?: string | null&#10;  preferences?: any&#10;  updatedAt: Date&#10;  createdAt: Date&#10;}&#10;&#10;// ==================== USER OPERATIONS ====================&#10;&#10;export async function createUser(data: {&#10;  email?: string&#10;  name?: string&#10;  username?: string&#10;  passwordHash?: string&#10;}) {&#10;  console.log('[DB] Creating user:', data.email || data.username)&#10;&#10;  const user = await prisma.user.create({&#10;    data: {&#10;      email: data.email,&#10;      name: data.name,&#10;      username: data.username,&#10;      passwordHash: data.passwordHash,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] User created:', user.id)&#10;  return user&#10;}&#10;&#10;export async function getUserById(id: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { id },&#10;    include: {&#10;      settings: true,&#10;    },&#10;  })&#10;}&#10;&#10;export async function getUserByEmail(email: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { email },&#10;  })&#10;}&#10;&#10;export async function getUserByUsername(username: string) {&#10;  return await prisma.user.findUnique({&#10;    where: { username },&#10;  })&#10;}&#10;&#10;// ==================== TASK OPERATIONS ====================&#10;&#10;export async function getTasks(filters?: {&#10;  userId?: string&#10;  status?: string&#10;  type?: string&#10;  tag?: string&#10;  isPublic?: boolean&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  console.log('[DB] Getting tasks with filters:', filters)&#10;&#10;  const where: any = {}&#10;&#10;  if (filters?.userId !== undefined) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.status) {&#10;    where.status = filters.status&#10;  }&#10;&#10;  if (filters?.type) {&#10;    where.type = filters.type&#10;  }&#10;&#10;  if (filters?.tag) {&#10;    where.tags = { has: filters.tag }&#10;  }&#10;&#10;  if (filters?.isPublic !== undefined) {&#10;    where.isPublic = filters.isPublic&#10;  }&#10;&#10;  const tasks = await prisma.task.findMany({&#10;    where,&#10;    orderBy: [&#10;      { priority: 'desc' },&#10;      { createdAt: 'desc' },&#10;    ],&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;    },&#10;  })&#10;&#10;  console.log(`[DB] Found ${tasks.length} tasks`)&#10;  return tasks&#10;}&#10;&#10;export async function getTaskById(id: string) {&#10;  console.log('[DB] Getting task by ID:', id)&#10;&#10;  const task = await prisma.task.findUnique({&#10;    where: { id },&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;      events: {&#10;        orderBy: { timestamp: 'desc' },&#10;        take: 50,&#10;      },&#10;    },&#10;  })&#10;&#10;  if (!task) {&#10;    console.log('[DB] Task not found:', id)&#10;    return null&#10;  }&#10;&#10;  console.log('[DB] Task found:', task.id)&#10;  return task&#10;}&#10;&#10;export async function createTask(data: {&#10;  userId?: string&#10;  title: string&#10;  description?: string&#10;  type?: string&#10;  payload?: any&#10;  tags?: string[]&#10;  priority?: number&#10;  isPublic?: boolean&#10;}) {&#10;  console.log('[DB] Creating task:', data.title)&#10;&#10;  const task = await prisma.task.create({&#10;    data: {&#10;      userId: data.userId,&#10;      title: data.title,&#10;      description: data.description,&#10;      type: data.type || 'general',&#10;      payload: data.payload,&#10;      tags: data.tags || [],&#10;      priority: data.priority || 0,&#10;      isPublic: data.isPublic || false,&#10;      status: 'pending',&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Task created:', task.id)&#10;  return task&#10;}&#10;&#10;export async function updateTask(id: string, data: Partial&lt;Task&gt;) {&#10;  console.log('[DB] Updating task:', id)&#10;&#10;  const task = await prisma.task.update({&#10;    where: { id },&#10;    data: {&#10;      title: data.title,&#10;      description: data.description,&#10;      status: data.status,&#10;      type: data.type,&#10;      payload: data.payload,&#10;      tags: data.tags,&#10;      lastRunAt: data.lastRunAt,&#10;      runnerStatus: data.runnerStatus,&#10;      outputText: data.outputText,&#10;      outputRaw: data.outputRaw,&#10;      errorMessage: data.errorMessage,&#10;      priority: data.priority,&#10;      isPublic: data.isPublic,&#10;      executionTime: data.executionTime,&#10;      updatedAt: new Date(),&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Task updated:', task.id)&#10;  return task&#10;}&#10;&#10;export async function deleteTask(id: string) {&#10;  console.log('[DB] Deleting task:', id)&#10;&#10;  await prisma.task.delete({&#10;    where: { id },&#10;  })&#10;&#10;  console.log('[DB] Task deleted:', id)&#10;}&#10;&#10;// ==================== EVENT OPERATIONS ====================&#10;&#10;export async function getEvents(filters?: {&#10;  userId?: string&#10;  taskId?: string&#10;  eventType?: string&#10;  level?: string&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  console.log('[DB] Getting events with filters:', filters)&#10;&#10;  const where: any = {}&#10;&#10;  if (filters?.userId) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.taskId) {&#10;    where.taskId = filters.taskId&#10;  }&#10;&#10;  if (filters?.eventType) {&#10;    where.eventType = filters.eventType&#10;  }&#10;&#10;  if (filters?.level) {&#10;    where.level = filters.level&#10;  }&#10;&#10;  const events = await prisma.event.findMany({&#10;    where,&#10;    orderBy: { timestamp: 'desc' },&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;    include: {&#10;      user: {&#10;        select: {&#10;          id: true,&#10;          name: true,&#10;          username: true,&#10;        },&#10;      },&#10;      task: {&#10;        select: {&#10;          id: true,&#10;          title: true,&#10;        },&#10;      },&#10;    },&#10;  })&#10;&#10;  console.log(`[DB] Found ${events.length} events`)&#10;  return events&#10;}&#10;&#10;export async function createEvent(data: {&#10;  userId?: string&#10;  taskId?: string&#10;  eventType: string&#10;  data?: any&#10;  level?: string&#10;}) {&#10;  console.log('[DB] Creating event:', data.eventType)&#10;&#10;  const event = await prisma.event.create({&#10;    data: {&#10;      userId: data.userId,&#10;      taskId: data.taskId,&#10;      eventType: data.eventType,&#10;      data: data.data,&#10;      level: data.level || 'info',&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Event created:', event.id)&#10;  return event&#10;}&#10;&#10;// ==================== SETTINGS OPERATIONS ====================&#10;&#10;export async function getSettings(userId?: string) {&#10;  console.log('[DB] Getting settings for user:', userId || 'global')&#10;&#10;  let settings = await prisma.settings.findFirst({&#10;    where: { userId: userId ?? null },&#10;  })&#10;&#10;  // Create default settings if not exists&#10;  if (!settings) {&#10;    console.log('[DB] Settings not found, creating defaults')&#10;    settings = await prisma.settings.create({&#10;      data: {&#10;        userId: userId,&#10;        preferences: {},&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Settings loaded:', settings.id)&#10;  return settings&#10;}&#10;&#10;export async function updateSettings(&#10;  userId: string | undefined,&#10;  data: {&#10;    runnerUrl?: string | null&#10;    runnerToken?: string | null&#10;    preferences?: any&#10;  }&#10;) {&#10;  console.log('[DB] Updating settings for user:', userId || 'global')&#10;&#10;  // Find existing settings&#10;  const existing = await prisma.settings.findFirst({&#10;    where: { userId: userId ?? null },&#10;  })&#10;&#10;  let settings&#10;  if (existing) {&#10;    // Update existing&#10;    settings = await prisma.settings.update({&#10;      where: { id: existing.id },&#10;      data: {&#10;        runnerUrl: data.runnerUrl,&#10;        runnerToken: data.runnerToken,&#10;        preferences: data.preferences,&#10;        updatedAt: new Date(),&#10;      },&#10;    })&#10;  } else {&#10;    // Create new&#10;    settings = await prisma.settings.create({&#10;      data: {&#10;        userId: userId,&#10;        runnerUrl: data.runnerUrl,&#10;        runnerToken: data.runnerToken,&#10;        preferences: data.preferences || {},&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Settings updated:', settings.id)&#10;  return settings&#10;}&#10;&#10;// ==================== AUDIT LOG OPERATIONS ====================&#10;&#10;export async function createAuditLog(data: {&#10;  userId?: string&#10;  action: string&#10;  resource?: string&#10;  metadata?: any&#10;  ipAddress?: string&#10;  userAgent?: string&#10;}) {&#10;  console.log('[DB] Creating audit log:', data.action)&#10;&#10;  const log = await prisma.auditLog.create({&#10;    data: {&#10;      userId: data.userId,&#10;      action: data.action,&#10;      resource: data.resource,&#10;      metadata: data.metadata,&#10;      ipAddress: data.ipAddress,&#10;      userAgent: data.userAgent,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] Audit log created:', log.id)&#10;  return log&#10;}&#10;&#10;export async function getAuditLogs(filters?: {&#10;  userId?: string&#10;  action?: string&#10;  limit?: number&#10;  offset?: number&#10;}) {&#10;  const where: any = {}&#10;&#10;  if (filters?.userId) {&#10;    where.userId = filters.userId&#10;  }&#10;&#10;  if (filters?.action) {&#10;    where.action = filters.action&#10;  }&#10;&#10;  return await prisma.auditLog.findMany({&#10;    where,&#10;    orderBy: { timestamp: 'desc' },&#10;    take: filters?.limit || 100,&#10;    skip: filters?.offset || 0,&#10;  })&#10;}&#10;&#10;// ==================== LLM SESSION OPERATIONS ====================&#10;&#10;export async function createLLMSession(data: {&#10;  userId?: string&#10;  sessionId: string&#10;  title?: string&#10;  systemPrompt?: string&#10;  metadata?: any&#10;}) {&#10;  console.log('[DB] Creating LLM session:', data.sessionId)&#10;&#10;  const session = await prisma.lLMSession.create({&#10;    data: {&#10;      userId: data.userId,&#10;      sessionId: data.sessionId,&#10;      title: data.title,&#10;      systemPrompt: data.systemPrompt,&#10;      metadata: data.metadata,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] LLM session created:', session.id)&#10;  return session&#10;}&#10;&#10;export async function getLLMSession(sessionId: string) {&#10;  return await prisma.lLMSession.findUnique({&#10;    where: { sessionId },&#10;    include: {&#10;      messages: {&#10;        orderBy: { timestamp: 'asc' },&#10;      },&#10;    },&#10;  })&#10;}&#10;&#10;export async function addLLMMessage(data: {&#10;  sessionId: string&#10;  role: string&#10;  content: string&#10;  metadata?: any&#10;}) {&#10;  console.log('[DB] Adding LLM message to session:', data.sessionId)&#10;&#10;  // Update session lastUsedAt&#10;  await prisma.lLMSession.update({&#10;    where: { sessionId: data.sessionId },&#10;    data: { lastUsedAt: new Date() },&#10;  })&#10;&#10;  const message = await prisma.lLMMessage.create({&#10;    data: {&#10;      session: {&#10;        connect: { sessionId: data.sessionId },&#10;      },&#10;      role: data.role,&#10;      content: data.content,&#10;      metadata: data.metadata,&#10;    },&#10;  })&#10;&#10;  console.log('[DB] LLM message created:', message.id)&#10;  return message&#10;}&#10;&#10;// ==================== SANDBOX FILE OPERATIONS ====================&#10;&#10;export async function saveSandboxFile(data: {&#10;  userId?: string&#10;  path: string&#10;  content: string&#10;  mimeType?: string&#10;}) {&#10;  console.log('[DB] Saving sandbox file:', data.path)&#10;&#10;  // Check if file exists&#10;  const existing = await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: data.userId ?? null,&#10;      path: data.path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;&#10;  let file&#10;  if (existing) {&#10;    // Update existing file&#10;    file = await prisma.sandboxFile.update({&#10;      where: { id: existing.id },&#10;      data: {&#10;        content: data.content,&#10;        size: Buffer.byteLength(data.content, 'utf8'),&#10;        mimeType: data.mimeType,&#10;        updatedAt: new Date(),&#10;      },&#10;    })&#10;  } else {&#10;    // Create new file&#10;    file = await prisma.sandboxFile.create({&#10;      data: {&#10;        userId: data.userId,&#10;        path: data.path,&#10;        content: data.content,&#10;        size: Buffer.byteLength(data.content, 'utf8'),&#10;        mimeType: data.mimeType,&#10;      },&#10;    })&#10;  }&#10;&#10;  console.log('[DB] Sandbox file saved:', file.id)&#10;  return file&#10;}&#10;&#10;export async function getSandboxFile(userId: string | undefined, path: string) {&#10;  return await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: userId ?? null,&#10;      path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;}&#10;&#10;export async function listSandboxFiles(userId?: string) {&#10;  return await prisma.sandboxFile.findMany({&#10;    where: {&#10;      userId: userId,&#10;      isDeleted: false,&#10;    },&#10;    orderBy: { updatedAt: 'desc' },&#10;  })&#10;}&#10;&#10;export async function deleteSandboxFile(userId: string | undefined, path: string) {&#10;  console.log('[DB] Deleting sandbox file:', path)&#10;&#10;  const file = await prisma.sandboxFile.findFirst({&#10;    where: {&#10;      userId: userId ?? null,&#10;      path,&#10;      isDeleted: false,&#10;    },&#10;  })&#10;&#10;  if (file) {&#10;    await prisma.sandboxFile.update({&#10;      where: { id: file.id },&#10;      data: {&#10;        isDeleted: true,&#10;      },&#10;    })&#10;    console.log('[DB] Sandbox file marked as deleted:', path)&#10;  } else {&#10;    console.log('[DB] Sandbox file not found:', path)&#10;  }&#10;}&#10;&#10;// ==================== UTILITY FUNCTIONS ====================&#10;&#10;export async function healthCheck() {&#10;  try {&#10;    await prisma.$queryRaw`SELECT 1`&#10;    return { ok: true, database: 'connected' }&#10;  } catch (error) {&#10;    console.error('[DB] Health check failed:', error)&#10;    return { ok: false, database: 'disconnected', error }&#10;  }&#10;}&#10;&#10;// Alias for API compatibility&#10;export const getDatabaseHealth = healthCheck&#10;&#10;export async function getDatabaseStats() {&#10;  const [&#10;    taskCount,&#10;    eventCount,&#10;    userCount,&#10;    sessionCount,&#10;  ] = await Promise.all([&#10;    prisma.task.count(),&#10;    prisma.event.count(),&#10;    prisma.user.count(),&#10;    prisma.lLMSession.count(),&#10;  ])&#10;&#10;  return {&#10;    tasks: taskCount,&#10;    events: eventCount,&#10;    users: userCount,&#10;    sessions: sessionCount,&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>